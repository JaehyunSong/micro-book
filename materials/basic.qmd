---
title: "第3回講義資料"
subtitle: "Rの基本的な操作"
toc: true
toc-title: "目次"
---

```{r}
#| include: false
knitr::opts_chunk$set(fig.align = "center")
rm(list = ls())
```

## 電卓としてのR

**手順1:** File > New File > R Scriptをクリックする。

```{r}
#| echo: false
#| out-width: "700px"
knitr::include_graphics("Figs/03/Script_1.png")
```

**手順2:** Sourceペインのペイン最大化ポタンをクリックし、Sourceペインの大きさ最大化する。

```{r}
#| echo: false
#| out-width: "700px"
knitr::include_graphics("Figs/03/Script_2.png")
```

**手順3:** Sourceペインに以下の内容を入力する。

```{r}
#| eval: false
1 + 1
```

**手順4:** コードの行にカーソルをおいたままCmd + Return（Windowsの場合、Control (Ctrl) + Enter）を入力する。これはカーソルが位置する行のコードを実行するコマンドである。

:::{.callout-note}
## カーソルって...?

カーソル (cursor)とは文字の入力位置を意味する。RStudioのテーマによって色は異なるが、Sourceペイン、またはConsoleペインなど、何らかの文字が入力できる箇所において点滅する「`|`」がカーソルです。
:::

**手順5:** Consoleペインに結果が表示される。

```{r}
#| echo: false
1 + 1
```

　これくらいの計算はConsoleペインで直接打ち込んでも良いが、自分がこれまで書いたコードを残すという意味でSourceペインに入力することを推奨する。R Scriptを保存しておけばいつでも開いて前回のコードを再現できる。

## コメント

　Rのスクリプトを作成する際、何かのメモを書いておきたいケースが多々ある。コードが長くなったり、複雑になったりすると、自分が書いたコードでも意味がよく分からないケースも多く発生する。これはデータ分析のプロでも例外でなく、宋も同じである。この場合、スクリプト内にこまめにメモを書いておくと、このコードが何のためのコードかなどが素早く把握できる。

　Rにおけるコメントは`#`を使用する。同じ行における`#`以降の内容は処理に影響を与えない。たとえば、以下のコードだと`# 12345と12345の積`は処理に影響を与えない

```{r}
# 12345と12345の積
12345 * 12345
```

　また、コードと同じ行にコメントを書くこともできる。

```{r}
12345 * 12345 # 12345と12345の積
```

　コードにこまめにコメントを書くのは意外と面倒な作業であるが、コメントに「書きすぎ」は存在しない。書けば書くほど未来の自分から感謝されるだろう。

## 算術演算子

　算術演算子は数字と数字の間に入力し、結果として何らかの**数字**が返される演算子である。先ほどの`+`や`*`も算術演算子（足し算と掛け算）である。ここでは良く使う算術演算子7つを紹介する。

| 演算子    | 意味            | 例                  | 結果 |
|:---------:|-----------------|---------------------|-----:|
| `+`       | 和              |`2 + 5`              |  7   |
| `-`       | 差              |`2 - 8`              | -6   |
| `*`       | 積              |`7 * 3`              | 21   |
| `/`       | 商              |`16 / 5`             |  3.2 |
| `^`、`**` | 累乗（べき乗）  | `2^3`または`2 ** 3` |  8   |
| `%%`      | 剰余 (モジュロ) | `18 %% 7`           |  4   |
| `%/%`     | 整数商          | `18 %/% 7`          |  2   |

　例を見てみよう。

```{r}
1 + 5  # 足し算
3 - 10 # 引き算
19 * 2 # 掛け算
13 / 7 # 割り算
5^3    # 5の3乗
```

　これは義務ではないがないが、累乗（`^`）を除き、演算子の前後にはスペースを入れるのがRの流儀であり、コードが読みやすくなる。以下のコードを比べてみよう。

```{r}
# 読みにくい例
(((3+5)*4)+((5%%2)+3))^2
# 読みやすい例
(((3 + 5) * 4) + ((5 %% 2) + 3))^2
```

　結果は同じだが、後者の方が読みやすいだろう。これから紹介する論理演算子でも共通する内容であるが、「累乗（`^`）を除き、演算子の前後にはスペースを入れる」ことを覚えておこう。ちなみにカッコ（`(`と`)`）は演算子ではないため、スペースは不要である。

## 論理演算子

　算術演算子は結果として数値が返ってくるが、論理演算子は真（`TRUE`）か偽（`FALSE`）のいずれかの値を返す演算子である。ここではまず、大小関係を判定する論理演算子を紹介する。

|演算子  |意味                      |例                              |結果   |
|--------|--------------------------|--------------------------------|-------|
|`x < y` |`x`は`y`より小さい        |`3 < 1`                         |`FALSE`|
|`x <= y`|`x`は`y`と等しいか、小さい|`2 <= 2`                        |`TRUE` |
|`x > y` |`x`は`y`より大きい        |`6 > 5`                         |`TRUE` |
|`x >= y`|`x`は`y`と等しいか、大きい|`4 >= 5`                        |`FALSE`|
|`x == y`|`x`と`y`は等しい          |`(2 + 3) == (4 + 1)`            |`TRUE` |
|`x != y`|`x`と`y`は等しくない      |`((2 * 3) + 1) != (2 * (3 + 1))`|`TRUE` |

　一つ注意すべき点は「等しい」を意味する論理演算子は`=`でなく、`==`だということだ[^equal-operator]。

[^equal-operator]: 他のプログラミング言語の経験があれば分かるだろうが、ほとんどのプログラミング言語において`=`は「代入」を意味し、Rも例外ではない。ただし、Rにおける代入には`=`と`<-`の2つの方法があり、後者が推奨される。

```{r}
3 > 2 # 3は2より大きいの?
5 <= 10 # 5は10と同じか小さいの?
2 + 3 == 1 # 2と3の和は1なの?
2 + 2 != 2 * 2 # 2と2の和は2と2の積と同じなの?
```

　算術演算子は一行に何回も使えるが、通常、論理演算子は一行に一つしか使えない。複数の論理演算子を使うためには、`&`（AND演算子）と`|`（OR演算子）を使う必要がある。

　AND演算子`&`は、`&`を挟む左右の**両側**が`TRUE`の場合のみ`TRUE`を返す演算子である。

```{r}
(2 + 3 == 5) & (2 * 3 == 5) # TRUE and FALSEだから... FALSE!
(2 + 3 == 5) & (2 * 3 == 6) # TRUE and TRUEだから... TRUE!
```

　OR演算子`|`は、`|`を挟む左右の**片側、あるいは両側**が`TRUE`の場合のみ`TRUE`を返す論理演算子である。

```{r}
(2 + 3 == 5) & (2 * 3 == 5) # TRUE or FALSEだから... TRUE!
(2 + 3 == 5) & (2 * 3 == 6) # TRUE or TRUEだから... TRUE!
(2 + 3 == 6) & (2 * 3 == 5) # FALSE or FALSEだから... FALSE!
```

　論理演算子には他にもいくつかあるが、説明は割愛する。

* `!`: 否定演算子（`TRUE`なら`FALSE`、`FALSE`なら`TRUE`が返ってくる。意外と良く使う）
* `&&`: `&`と同じ
* `||`: `|`と同じ
* `xor()`: 排他的論理和（`xor(FALSE, TRUE)`と`xor(TRUE, FALSE)`の場合のみ`TRUE`が返ってくる。論理回路に興味あれば重要な演算子だが、実際に使うケースはあまりない。）

　論理演算子が活躍するのはデータ加工（データハンドリング）の時である。何かの条件を指定して、その行件に合致するケースのみを抽出する場合は、これらの論理演算子の使用が必須である。

:::{.callout-tip}
## マッチング演算子: `%in%`

もう一つ便利な論理演算子としてマッチング演算子`%in%`がある。これについてはデータハンドリングの講義で解説する。
:::

## 代入とベクトル

　まず、以下のような例を考えてみよう。

* 123454321 $\times$ 2を計算してみよう
* 123454321 $\times$ 3を計算してみよう
* 123454321 $\times$ 4を計算してみよう
* ...
* 123454321 $\times$ 200を計算してみよう

```r
123454321 * 2
123454321 * 3
123454321 * 4

(省略)

123454321 * 198
123454321 * 199
123454321 * 200
```

　このように199行のコードを書く必要がある。もう少し効率的な方法はないだろうか。まず、この`123454321`を書く手間をなんとかしてみよう。

* **方法1:** `123454321`をコピーし貼り付けながら計算を繰り返す
* **方法2:** `123454321`に`x`という名前を付けて、`x * 1`のように表記する（**ここが重要**）

　いずれも有効な方法であるが、方法1には致命的なデメリットがある。それは修正が面倒だという点である。もし「あ、ごめん！123454321じゃなくて、23235211だったわ！コード直してもらえる？」と言われたら、199行のコードをすべて修正する必要がある。一方、方法2を使えば、「`123454321`に`x`という名前を付ける」コードのみを修正すれば良い。このように何かの数字、文字列などに名前を付けて後から使えるようにする作業を**代入**（assignment）と呼ぶ。

　代入の話をする前にRにおけるデータ構造の一種である**ベクトル**（vector）の話をしなければならない。ベクトルは**Rにけるデータの最小単位**である。Rには様々なデータ構造があるが、これらはすべてベクトルの集合と言っても過言ではない。このベクトルには以下のような特徴がある。

**ベクトルの特徴**

* ベクトルの長さは1以上である。
  * `1`や`"Cat"`は長さ1のベクトル
  * 長さ1のベクトルは原子ベクトル（atomic vector）とも呼ばれる。
* 一つのベクトル同じデータ型（数値、文字列など）で構成される。
  * 数値と文字列が混在するベクトルは作成できない。

:::{.callout-note}
## データ型? データ構造?

データ型とデータ構造については今後の講義で解説する。
:::

　まずはこの2つだけ覚えておけば問題ない。重要なのはベクトルの作り方であるが、長さ1のベクトルであれば、`1`、`"Cat"`などで十分である。もし、ながさ2以上のベクトルを作る場合は`c()`関数を使う。`()`内にコンマ区切りの要素 (element)を入れるだけである。

```{r}
19861008 # 長さ1の数値型ベクトル
c(1986, 10, 8) # 長さ3の数値型ベクトル
```

:::{.callout-tip}
## `,`の後にはスペースを入れよう！

コードの可読性の観点から見ると、`c(1986,10,8)`より`c(1986, 10, 8)`の方が読みやすい。
:::

　それでは、（原子ベクトルを含む）ベクトルに名前を付ける方法について紹介する。それは代入演算子`<-`である。`x <- 123454321`は`x`という器に`123454321`という数字を入れることを意味する。ここでいう「器」のことを**オブジェクト**（object）と呼ぶ。オブジェクトに関する説明は今後の講義で解説する。オブジェクトの内容を確認するためにはオブジェクトの名前のみを入力する。

```{r}
x <- 123454321 # xに123454321を代入
x
```

　先ほどの作業は以下のように簡略化することができる。

```r
x <- 123454321 # xに123454321を代入
x * 2
x * 3
x * 4

(省略)

x * 198
x * 199
x * 200
```

　これを使えば、もし修正要請があったとしても`x <- 123454321`の部分だけ修正すれば良いだろう。ただ、それでも200行のコード（代入で1行、計算で199行）を書くことには代わりがない。これをなんとか出来ないだろうか。以上のコードは1〜3行にまとめることができる。そのためにベクトル同士の計算について考える必要がある。同じ長さのベクトル同士の計算の場合、同じ位置の要素同士の計算が行われる。以下の例を考えてみよう。

```{r}
my_vec1 <- c(1, 2, 3, 4, 5, 6)
my_vec2 <- c(0, 1, 2, 0, 1, 2)
my_vec1 * my_vec2
```

　上記のコードは以下のように表すことができる。

|ベクトル/位置|1番目|2番目|3番目|4番目|5番目|6番目|
|---|:---:|:---:|:---:|:---:|:---:|:---:|
|`my_vec1`|1|2|3|4|5|6|
||$\times$|$\times$|$\times$|$\times$|$\times$|$\times$|
|`my_vec2`|0|1|2|0|1|2|
|結果|0|2|6|0|5|12|

　もし、ベクトルの長さが一致しない場合はどうなるだろうか。この場合、短い方のベクトルが繰り返されることとなり、これを**ベクトル・リサイクル**（vector recycle）と呼ぶ。以下の例では`my_vec4`の方が短いため、`3 * 2`までの計算が終わったあと、もう一回`my_vec4`の1番目の要素、`0`が使われることになる。

```{r}
my_vec3 <- c(1, 2, 3, 4, 5, 6)
my_vec4 <- c(0, 1, 2)
my_vec3 * my_vec4
```

　このベクトル・リサイクルを利用すれば簡単に199行のコードを簡略化できよう。ただし、2から200まで格納されている長さ199のベクトルを作るのが面倒かも知れない。2, 3, 4, ..., 199, 200は公差1の等差数列であり、Rでは`seq()`関数を使うことで等差数列を簡単に作ることができる。たとえば、2から10までの公差1の等差数列であれば、以下のように作れる。

```{r}
seq(2, 10, by = 1) # 2から10までの公差1の等差数列
```

　公差1でなく公差2であれば、`by = 1`を`by = 2`に修正する。

```{r}
seq(2, 10, by = 2) # 2から10までの公差2の等差数列
```

　また、公差1の等差数列であれば、`:`演算子を使うこともできる。

```{r}
2:10 # 2から10までの公差1の等差数列
```

　これで199行のコードを簡略化する準備は整った。まずは3行に簡略化した例を見てみよう。

```{r}
# 3行の例
x <- 123454321
y <- 2:200 # または、y <- seq(2, 200, by = 1)
x * y
```

　これを2行にまとめる場合は、`x`と`y`いずれかをベクトルとして格納し、もう片方は格納せずそのまま計算に使う（結果は省略）。

```{r}
#| eval: false
# 2行の例 (1)
x <- 123454321
x * 2:200
```

```{r}
#| eval: false
# 2行の例 (2)
x <- 2:200
123454321 * x
```

　究極のやり方は`x`も`y`も格納せずそのまま使う方法であり、これなら1行にまとめることができる（結果は省略）。

```{r}
#| eval: false
# 1行の例
123454321 * 2:200
```

## 表形式データの読み込み

```{r}
#| message: false
library(tidyverse)
```

```{r}
my_data <- read_csv("Data/Pref_Vote.csv")
```

```{r}
ls()
```

```{r}
my_data # または、print(my_data)
```

```
# … with 37 more rows, and 2 more variables: Region2 <dbl>, Region6 <dbl>
```

出力された内容以外にも36行が更にあり、`Region2`と`Region6`という名の列もある。もし、20行を出力したい場合は`print(オブジェクト名, n = 20)`と入力する。

```{r}
print(my_data, n = 20)
```

最初の6行のみを出力する場合は`head()`、最後の6行を出力する場合は`tail()`を使う。

```{r}
head(my_data)
```

```{r}
tail(my_data)
```

6行でなく、任意の行数を指定したい場合は`head()`、または`tail()`内に`n = ...`を追加する。