---
title: "第11回講義資料"
subtitle: "データハンドリング (3)"
toc: true
link-external-icon: true
link-external-newwindow: true
---

## スライド

<a href="../slide/slide11.html" class="btn btn-primary btn-sm" target="_blank" role="button"><i class="bi bi-window"></i> 新しいタブで開く</a>

```{=html}
<iframe class="slide-deck" src="../slide/slide11.html" width="100%" style="aspect-ratio: 16 / 9.2;"></iframe>
```

```{r}
#| include: false
library(tidyverse)
knitr::opts_chunk$set(dev       = "ragg_png",
                      dpi       = 300,
                      fig.align = "center",
                      echo      = TRUE)
```

## データの結合

### 行の結合

`bind_rows()`を利用: 変数名が一致する必要がある

* 以下の例はいずれのdata.frameも`ID`、`Name`、`Score`で構成されている。
   * `ID`、`Name`、`Score`の順番は一致しなくても良い（上のdata.frameの順番に調整される）。

:::: {.columns}

::: {.column width=48%}
**結合前**

```{r}
#| include: false
Data1 <- data.frame(ID    = 1:3, 
                    Name  = c("Aさん", "Bさん", "Cさん"),
                    Score = c(77, 89, 41))
Data2 <- data.frame(ID    = 4:5, 
                    Name  = c("Xさん", "Yさん"),
                    Score = c(98, 78))
```

```{r}
Data1
Data2
```
:::

::: {.column width=4%}
:::

::: {.column width=48%}
**結合後**

```{r}
bind_rows(Data1, Data2)
```
:::

::::

結合前のデータ識別変数の追加

* 結合するデータを`list()`でまとめ、`.id`引数を追加する
* `list()`の内部では`"識別変数の値" = 結合するデータ`と定義

**例)** 結合後、`Class`という列を追加し、元々`Data1`だった行は`"1組"`、`Data2`だった行には`"2組"`を格納する。

```{r}
bind_rows(list("1組" = Data1, "2組" = Data2),
          .id = "Class")
```

### 列の結合

`*_join()`: 結合に使う識別用の変数（**キー変数**）が必要（以下では`City`）

:::: {.columns}

::: {.column width=48%}
**結合前**

```{r}
#| echo: false
Data1 <- data.frame(City  = c("Tokyo", "Osaka", "Kochi"),
                    Pop   = c(927, 148, 76),
                    Area  = c(2194, 828, 7104))
```

```{r}
Data1
```
:::

::: {.column width=4%}
:::

::: {.column width=48%}
**結合前**

```{r}
#| echo: false
Data2 <- data.frame(City  = c("Kochi", "Osaka", "Tokyo"),
                    Food  = c("Katsuo", "Takoyaki", "Ramen"))
```

```{r}
Data2
```
:::

::::

**結合後**

```{r}
left_join(Data1, Data2, by = "City")
```

識別子は両データに含まれているが、一致しないケースがある。

* どのデータの識別子を優先するか

1. `left_join()`
   * 左側のデータの識別子を優先する
   * 空欄は欠損値として埋められる
2. `right_join()`
   * 右側のデータの識別子を優先する
   * 空欄は欠損値として埋められる
3. `inner_join()`
   * 両データの識別子に共通する行のみを残して結合
4. `full_join()`
   * 両データの識別子に存在する行すべて結合
   * 空欄は欠損値として埋められる

`left_join()`の仕組み

`left_join(データ1, データ2, by = "識別用変数名")`

* データ1を温存する
* 欠損しているセルは欠損値（`NA`）で埋められる

:::: {.columns}

::: {.column width=50%}
```{r}
#| echo: false
#| out-width: "600px"
knitr::include_graphics("Figs/10/Merge_Left.png")
```
:::
::: {.column width=50%}
```{r}
#| echo: false
knitr::include_graphics("Figs/10/left-join.gif")
```
:::

::::

`right_join()`の仕組み

`right_join(データ1, データ2, by = "識別用変数名")`

* データ2を温存する
* 欠損しているセルは欠損値（`NA`）で埋められる

:::: {.columns}

::: {.column width=50%}
```{r}
#| echo: false
#| out-width: "600px"
knitr::include_graphics("Figs/10/Merge_Right.png")
```
:::
::: {.column width=50%}
```{r}
#| echo: false
knitr::include_graphics("Figs/10/right-join.gif")
```
:::

::::

`inner_join()`の仕組み

`inner_join(データ1, データ2, by = "識別用変数名")`

* データ1とデータ2で識別子が共通する行のみ結合

:::: {.columns}

::: {.column width=50%}
```{r}
#| echo: false
#| out-width: "600px"
knitr::include_graphics("Figs/10/Merge_Inner.png")
```
:::
::: {.column width=50%}
```{r}
#| echo: false
knitr::include_graphics("Figs/10/inner-join.gif")
```
:::

::::

`full_join()`の仕組み

`full_join(データ1, データ2, by = "識別用変数名")`

* データ1とデータ2をすべて温存
* 欠損しているセルは欠損値（`NA`）で埋められる

:::: {.columns}

::: {.column width=50%}
```{r}
#| echo: false
#| out-width: "600px"
knitr::include_graphics("Figs/10/Merge_Full.png")
```
:::
::: {.column width=50%}
```{r}
#| echo: false
knitr::include_graphics("Figs/10/full-join.gif")
```
:::

::::

比較 (1)

```{r}
df1 <- tibble(Pref  = c("東京", "大阪", "京都"),
              Score = c(3.5, 4, 4.2))
df2 <- tibble(Pref  = c("東京", "大阪", "高知"),
              N     = c(3220, 1325, 111))
```

:::: {.columns}

::: {.column width=48%}
```{r}
df1
```
:::

::: {.column width=4%}
:::

::: {.column width=48%}
```{r}
df2
```
:::

::::

比較 (2)

`by = "識別用の変数名"`は複数用いることも可能（例: 都道府県名&年度で結合）

* `by = c("識別用の変数名1", "識別用の変数名2")`

:::: {.columns}

::: {.column width=48%}
```{r}
left_join(df1, df2, by = "Pref")
right_join(df1, df2, by = "Pref")
```
:::

::: {.column width=4%}
:::

::: {.column width=48%}
```{r}
inner_join(df1, df2, by = "Pref")
full_join(df1, df2, by = "Pref")
```
:::

::::

## 整然データ構造

Tidy data: Hadley Wickhamが提唱した**データ分析に適したデータ構造**

:::: {.columns}

::: {.column width=70%}
* **整然データ**、簡潔データと呼ばれる
* パソコンにとって読みやすいデータ $\neq$ 人間にとって読みやすいデータ
* {tidyr}パッケージは雑然データを整然データへ変形するパッケージ
* 次回紹介する{ggplot2}は整然データを前提として開発されたパッケージ

4つの原則

1. 1つの列は、1つの変数を表す
2. 1つの行は、1つの観測を表す
3. 1つのセルは、1つの値を表す
4. 1つの表は、1つの観測単位をもつ
:::

::: {.column width=2%}
:::

::: {.column width=28%}
```{r}
#| echo: false
#| out-width: "300px"
knitr::include_graphics("Figs/10/TidyingUp.jpg")
```
:::

::::

### 4つの原則

原則1: 1列1変数

* 1列には1つの変数のみ
  * 3人の被験者に対し、薬を飲む前後の数学成績を測定した場合
  * 薬を飲む前: Control / 薬を飲んだ後: Treatment

```{r}
#| echo: false
#| out-width: "800px"
knitr::include_graphics("Figs/10/TidyData1.png")
```

原則2: 1行1観察

* 1観察 $\neq$ 1値
  * 観察: 観察単位ごとに測定された**値の集合**
  * 観察単位: 人、企業、国、時間など
* 以下の例の場合、観察単位は「人 $\times$ 時間 」

```{r}
#| echo: false
#| out-width: "800px"
knitr::include_graphics("Figs/10/TidyData2.png")
```

原則3: 1セル1値

* この原則に反するケースは多くない
* **例外)** 1セルに`2020年8月24日`という値がある場合
  * 分析の目的によっては年月日を全て異なるセルに割り当てる必要もある
  * このままで問題とならないケースも

```{r}
#| echo: false
#| out-width: "400px"
knitr::include_graphics("Figs/10/TidyData3.png")
```

原則4: 1表1単位

* 政府統計: 日本を代表する雑然データ
  * データの中身は良いが、構造が...
  * 表に「国」、「都道府県」、「市区町村」、「行政区」の単位が混在

```{r}
#| echo: false
#| out-width: "800px"
knitr::include_graphics("Figs/10/TidyData4.png")
```

原則4: 1表1単位

* 「1表1単位」原則を満たさない場合、`filter()`関数等で、異なる単位の行を除外
   * 以降、解説する{tidyr}でなく、{dplyr}で対応可能

```{r}
#| echo: false
#| out-width: "500px"
knitr::include_graphics("Figs/10/TidyData5.png")
```

### {tidyr}パッケージ

```{r}
#| echo: false
#| out-width: "200px"
knitr::include_graphics("Figs/10/tidyr.png")
```

雑然データから整然データへ変形をサポートするパッケージ

* `pivot_longer()`: Wide型データからLong型データへ
   * 原則1・2に反するデータを整然データへ変換 (最も頻繁に使われる)
* `pivot_wider()`: Long型データからWide型データへ
   * 人間には雑然データの方が読みやすい場合がある（原則1の例）
* `separate()`: セルの分割（「年月日」から「年」、「月」、「日」へ）
   * 原則3に反するデータを整然データへ変換
* 原則4に反するデータは単位がずれている行を`filter()`などで除外

実習用データ

`Micro10.csv`: 日本、韓国、モンゴル、台湾の5日間COVID-19新規感染者数

* サポートページからダウンロード
* データ出典:[Johns Hopkins University Center for Systems Science and Engineering](https://github.com/CSSEGISandData/COVID-19)

```{r}
#| message: false
COVID_df <- read_csv("Data/Micro10.csv")
COVID_df
```

このデータの問題点

* 観察単位は? 測定した変数は?
  * 観察単位: 地域 $\times$ 時間
  * 変数: 新規感染者数
* 新規感染者数が5列にわたって格納されている

```{r}
#| echo: false
knitr::kable(COVID_df)
```

Wide型からLong型へ

* 整然な`COVID_df`の構造は?
  * 5列を1列にまとめるため、縦に長くなる
  * WideからLongへ

```{r}
#| echo: false
COVID_df %>% 
  pivot_longer(cols      = `2021/05/24`:`2021/05/28`,
               names_to  = "Date",
               values_to = "New_Cases") %>%
  knitr::kable()
```

`pivot_longer()`: Wide to Long

* `cols`は`dplyr::select()`と同じ使い方
  * `c()`で個別の変数名を指定することも、`:`や`starts_with()`を使うこともOK
  * **注意:** 変数名が数字で始まったり、記号が含まれている場合、変数名を`` ` ``か`"`で囲む
    * 列名が日付の場合、数字で始まったり、記号（`/`や`-`など）が含まれるケースが多い
  
```{r}
#| eval: false
データ %>%
  pivot_longer(cols      = 変数が格納されている列,
               names_to  = "元の列名が入る変数名",
               values_to = "変数の値が入る変数名")
```

`pivot_longer()`: WideからLongへ

* `cols = starts_with("2020")`もOK

```{r}
#| code-line-numbers: "2-4"
COVID_Long <- COVID_df %>% 
  pivot_longer(cols      = "2021/05/24":"2021/05/28",
               names_to  = "Date",
               values_to = "New_Cases")
COVID_Long
```

`pivot_wider()`: LongからWideへ

* Long型をWide型へ戻す関数
  * 人間にとってはLong型よりWide型の方が読みやすいケースも多い
  * 1列に2つの変数が入っている場合もある

```{r}
#| code-line-numbers: "2,3"
COVID_Long %>%
  pivot_wider(names_from  = "Date",
              values_from = "New_Cases")
```

`separate()`: 列の分割

`COVID_Long`の`Date`列を`Year`、`Month`、`Day`に分けたい

* **例)** `Date`列を`"/"`を基準に分割する

```{r}
#| eval: false
データ %>%
  separate(col  = "分割する列名",
           into = c("分割後の列名1", "分割後の列名2", ...),
           sep  = "分割する基準")
```

`separate()`: 列の分割

```{r}
#| code-line-numbers: "2-4"
COVID_Long %>%
  separate(col  = "Date",
           into = c("Year", "Month", "Day"),
           sep  = "/")
```

列の分割（番外編）: 特定の記号がない場合

**例)** `City_Data`の`City`列が「都道府県名+市区町村」

* 「最初の3文字」と「残り」で分割することは出来ない（神奈川、和歌山、鹿児島）
* 任意の2文字の後に「都」、「道」、「府」、「県」が付くか、任意の3文字の後に「県」が付く箇所を見つけて分割
   * かなり複雑

```{r}
#| echo: false
City_Data <- tibble(City = c("北海道音威子府村",
                             "大阪府高槻市",
                             "広島県府中市",
                             "鹿児島県指宿市"),
                    Pop  = c(693, 347424, 36471, 38207))

City_Data
```

**正則表現（regular expression）**の知識が必要

* テキスト分析に興味があるなら必須（前期・後期含めて、本講義では解説しない）

```{r}
City_Data %>%
   # 任意の2文字の後に「都道府県」のいずれかが来るか、
   # 任意の3文字の後に「県」が来たら、そこまでをブロック1、残りをブロック2とする
   # Cityの値を「ブロック1-ブロック2」に置換する
   mutate(City = str_replace(City, "^(.{2}[都道府県]|.{3}県)(.+)", 
                             "\\1-\\2")) %>%
   # 「-」を基準に列を分割
   separate(col  = "City", into = c("Pref", "City"), sep  = "-")
```

### {tidyr}と{dplyr}

{tidyr}と{dplyr}を組み合わせることも可能

* **例)** 100万人当たりの新規感染者数を計算し、国ごとに平均値を計算

```{r}
COVID_df %>% 
  pivot_longer(cols      = "2021/05/24":"2021/05/28",
               names_to  = "Date",
               values_to = "New_Cases") %>%
   mutate(New_Case_per_1M = New_Cases / Population * 1000000) %>%
   group_by(Country) %>%
   summarise(New_Case_per_1M = mean(New_Case_per_1M))
```

## 教科書

* データの結合: 『私たちのR: ベストプラクティスの探求』[第13.5章](https://www.jaysong.net/RBook/datahandling2.html#handling2-merge)
* 整然データ構造: 『私たちのR: ベストプラクティスの探求』[第15章](https://www.jaysong.net/RBook/tidydata.html)